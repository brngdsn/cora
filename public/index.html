<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Book Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Include PDFKit and Blob-Stream -->
  <script src="https://unpkg.com/pdfkit@0.15.0/js/pdfkit.standalone.js"></script>
  <script src="https://unpkg.com/blob-stream@0.1.3/.js"></script>
  <style>
    /* Existing styles */

    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    header {
      display: flex;
      align-items: center;
      padding: 10px;
      background-color: #333;
      color: #fff;
    }
    .logo {
      flex: 1;
    }
    nav ul {
      list-style: none;
      display: flex;
      flex: 2;
      justify-content: center;
    }
    nav ul li {
      margin: 0 15px;
    }
    .login {
      flex: 1;
      text-align: right;
    }
    .container {
      display: flex;
      height: calc(100% - 60px);
    }
    .editor, .preview {
      flex: 1;
      overflow: auto;
    }
    .editor {
      padding: 20px;
      background-color: #f5f5f5;
    }
    .preview {
      padding: 20px;
    }
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      .editor, .preview {
        height: 50%;
      }
    }

    /* Floating Input Styles */

    .floating-input {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      background-color: #fff;
      border-radius: 25px;
      padding: 5px 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    #floating-input-field {
      border: none;
      outline: none;
      padding: 10px;
      font-size: 16px;
      flex: 1;
    }

    .fab-buttons {
      display: flex;
      align-items: center;
    }

    .fab-button {
      width: 40px;
      height: 40px;
      margin-left: 3px;
      margin-right: 3px;
      border: none;
      border-radius: 50%;
      background-color: #4285F4;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
    }

    .fab-button:focus {
      outline: none;
    }

    /* Popup Menu Styles */

    .popup-menu {
      position: absolute;
      bottom: 60px;
      right: 0;
      background-color: #fff;
      border-radius: 5px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      display: none;
      max-height: 300px;
      overflow-y: auto;
      width: 250px;
      z-index: 1001;
    }

    .popup-menu ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .popup-menu li {
      padding: 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }

    .popup-menu li:hover {
      background-color: #f5f5f5;
    }

  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <div class="logo">PDF Book Builder</div>
    <nav>
      <ul>
        <li><a href="#" style="color: #fff;">Home</a></li>
        <li><a href="#" style="color: #fff;">Features</a></li>
      </ul>
    </nav>
    <div class="login"><a href="#" style="color: #fff;">Login</a></div>
  </header>

  <!-- Main Content -->
  <div class="container">
    <!-- Left Column: Text Editor -->
    <div class="editor">
      <textarea id="text-editor" style="width: 100%; height: 100%;"></textarea>
    </div>

    <!-- Right Column: PDF Preview -->
    <div class="preview">
      <iframe id="pdf-preview" width="100%" height="100%"></iframe>
    </div>
  </div>

  <!-- Floating Input -->
  <div class="floating-input">
    <input type="text" id="floating-input-field" placeholder="Type your prompt here..." />
    <div class="fab-buttons">
      <button id="submit-button" class="fab-button">
        &#x27A4; <!-- Submit Button -->
      </button>
      <button id="assistant-button" class="fab-button">
        &#128100; <!-- Assistant Selection Button -->
      </button>
      <button id="menu-button" class="fab-button">
        &#9776; <!-- Menu Button -->
      </button>
    </div>
    <!-- Assistant Menu -->
    <div id="assistant-menu" class="popup-menu">
      <!-- Assistant list will be populated dynamically -->
    </div>
    <!-- Popup Menu -->
    <div id="popup-menu" class="popup-menu">
      <!-- Existing chapter/subheading menu -->
    </div>
  </div>

  <script>
const bookData = [
  {
    "title": "React for Beginners",
    "chapters": [
      {
        "title": "Chapter 1: Introduction to ReactJS",
        "content": [
          {
            "type": "paragraph",
            "text": "Welcome to the first chapter of \"Mastering the ReactJS Interview.\" In this chapter, we will explore the fundamentals of ReactJS and understand why it has become a pivotal technology in modern web development."
          },
          {
            "type": "bullet-list",
            "items": [
              "The evolution of front-end development",
              "Why ReactJS is popular among developers and companies",
              "Understanding the component-based architecture"
            ]
          },
          {
            "type": "subheading",
            "text": "The Evolution of Front-End Development"
          },
          {
            "type": "paragraph",
            "text": "Front-end development has significantly evolved from static HTML pages to dynamic, interactive web applications. The need for efficient UI updates and state management led to the creation of JavaScript frameworks and libraries."
          },
          {
            "type": "paragraph",
            "text": "Traditional approaches involved manipulating the DOM directly, which could be inefficient and lead to complex, hard-to-maintain codebases as applications grew in size."
          },
          {
            "type": "subheading",
            "text": "Why ReactJS is Popular Among Developers and Companies"
          },
          {
            "type": "paragraph",
            "text": "ReactJS addresses many of the challenges faced in front-end development. Here are some reasons for its popularity:"
          },
          {
            "type": "bullet-list",
            "items": [
              "**Declarative Syntax:** Makes code more predictable and easier to debug.",
              "**Component-Based Architecture:** Encourages reusability and modular code.",
              "**Virtual DOM:** Improves performance by minimizing direct DOM manipulations.",
              "**Strong Community Support:** Extensive ecosystem of tools and libraries.",
              "**Flexibility:** Can be used with other frameworks and supports React Native for mobile development."
            ]
          },
          {
            "type": "subheading",
            "text": "Understanding the Component-Based Architecture"
          },
          {
            "type": "paragraph",
            "text": "Components are the building blocks of a React application. They allow you to split the UI into independent, reusable pieces that can be managed separately."
          },
          {
            "type": "code",
            "code": "// Example of a simple React component\nimport React from 'react';\n\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}!</h1>;\n}\n\nexport default Welcome;"
          },
          {
            "type": "paragraph",
            "text": "In the example above, the `Welcome` component is a functional component that takes `props` as an argument and returns a JSX element."
          },
          {
            "type": "paragraph",
            "text": "Components can be composed to build complex user interfaces, promoting better organization and maintainability in your codebase."
          },
          {
            "type": "code",
            "code": "// Composing components\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Alice\" />\n      <Welcome name=\"Bob\" />\n      <Welcome name=\"Charlie\" />\n    </div>\n  );\n}"
          },
          {
            "type": "paragraph",
            "text": "By understanding these core concepts, you'll be well on your way to mastering ReactJS and impressing in your interviews."
          }
        ]
      }
    ]
  }
];
  </script>

  <!-- Scripts -->
  <script>
    // Ensure bookData is available
    if (typeof bookData === 'undefined') {
      console.error('bookData is not defined. Make sure book-data.js is included.');
    }

    // Function to convert JSON data to plain text
    function jsonToPlainText(data) {
      let text = '';

      data.forEach(book => {
        text += `# ${book.title}\n\n`;
        if (book.content) {
          // Content outside chapters
          text += processContentArray(book.content);
        }
        if (book.chapters) {
          book.chapters.forEach(chapter => {
            text += `## ${chapter.title}\n\n`;
            text += processContentArray(chapter.content);
          });
        }
      });

      return text;
    }

    // Helper function to process content arrays
    function processContentArray(contents) {
      let text = '';
      contents.forEach(item => {
        switch (item.type) {
          case 'paragraph':
            text += `${item.text}\n\n`;
            break;
          case 'subheading':
            text += `### ${item.text}\n\n`;
            break;
          case 'bullet-list':
            item.items.forEach(bullet => {
              text += `- ${bullet}\n`;
            });
            text += '\n';
            break;
          case 'code':
            text += `\`\`\`\n${item.code}\n\`\`\`\n\n`;
            break;
          case 'page-break':
            text += `---\n\n`;
            break;
          case 'chapter':
            text += `## ${item.title}\n\n`;
            text += processContentArray(item.content);
            break;
          default:
            break;
        }
      });
      return text;
    }

    // Function to convert plain text back to JSON
    function plainTextToJson(text) {
      const lines = text.split('\n');
      let book = {
        title: '',
        content: []
      };
      let currentChapter = null;
      let inCodeBlock = false;
      let codeBlockContent = '';

      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];

        // Skip empty lines
        if (line.trim() === '') {
          continue;
        }

        // Check for code block start/end
        if (line.trim() === '```') {
          inCodeBlock = !inCodeBlock;
          if (!inCodeBlock) {
            // End of code block
            let codeItem = {
              type: 'code',
              code: codeBlockContent.trim()
            };
            addToCurrentContext(codeItem);
            codeBlockContent = '';
          }
          continue;
        }

        if (inCodeBlock) {
          codeBlockContent += line + '\n';
          continue;
        }

        // Check for explicit page break
        if (line.trim() === '---') {
          let pageBreakItem = {
            type: 'page-break'
          };
          addToCurrentContext(pageBreakItem);
          continue;
        }

        if (line.startsWith('# ')) {
          // Book title
          book.title = line.substring(2).trim();
        } else if (line.startsWith('## ')) {
          // New chapter
          currentChapter = {
            type: 'chapter',
            title: line.substring(3).trim(),
            content: []
          };
          book.content.push(currentChapter);
        } else if (line.startsWith('### ')) {
          // Subheading
          let subheadingItem = {
            type: 'subheading',
            text: line.substring(4).trim()
          };
          addToCurrentContext(subheadingItem);
        } else if (line.startsWith('- ')) {
          // Bullet list
          let items = [];
          while (line && line.startsWith('- ')) {
            items.push(line.substring(2).trim());
            i++;
            if (i < lines.length) {
              line = lines[i];
            } else {
              break;
            }
          }
          i--; // Step back one line
          let bulletListItem = {
            type: 'bullet-list',
            items: items
          };
          addToCurrentContext(bulletListItem);
        } else {
          // Paragraph
          let paragraph = line;
          while (
            i + 1 < lines.length &&
            lines[i + 1].trim() !== '' &&
            !lines[i + 1].startsWith('#') &&
            !lines[i + 1].startsWith('```') &&
            !lines[i + 1].startsWith('- ') &&
            !lines[i + 1].startsWith('### ') &&
            !lines[i + 1].startsWith('## ') &&
            lines[i + 1].trim() !== '---'
          ) {
            i++;
            paragraph += '\n' + lines[i];
          }
          let paragraphItem = {
            type: 'paragraph',
            text: paragraph.trim()
          };
          addToCurrentContext(paragraphItem);
        }
      }

      return [book]; // Return as an array to match original structure

      // Helper function to add content to the current context
      function addToCurrentContext(item) {
        if (currentChapter) {
          currentChapter.content.push(item);
        } else {
          if (!book.content) {
            book.content = [];
          }
          book.content.push(item);
        }
      }
    }

    let textEditor, initialText;

    // Ensure bookData is available
    if (typeof bookData === 'undefined') {
      console.error('bookData is not defined. Make sure book-data.js is included.');
    } else {
      // Load initial text into the text editor from bookData
      initialText = jsonToPlainText(bookData);
      textEditor = document.getElementById('text-editor');
      textEditor.value = initialText;
    }

    // Function to generate PDF
    function generatePDF(content) {
      const doc = new PDFDocument({ autoFirstPage: false });
      const stream = doc.pipe(blobStream());

      // Parse the plain text content
      let books;
      try {
        books = plainTextToJson(content);
      } catch (e) {
        console.error('Error parsing text:', e);
        return;
      }

      books.forEach(book => {
        // Add book title
        if (book.title) {
          doc.addPage();
          doc.fontSize(24).text(book.title, { align: 'center' });
          doc.moveDown();
        }

        // Process the book content
        processContentArray(book.content);
      });

      // Finalize PDF file
      doc.end();

      // Stream the PDF into a blob and display in iframe
      stream.on('finish', function() {
        const url = stream.toBlobURL('application/pdf');
        document.getElementById('pdf-preview').src = url;
      });

      // Helper function to process content arrays
      function processContentArray(contents) {
        contents.forEach(item => {
          switch (item.type) {
            case 'chapter':
              doc.addPage();
              doc.fontSize(20).text(item.title, { underline: true });
              doc.moveDown();
              processContentArray(item.content);
              break;
            case 'subheading':
              doc.fontSize(16).text(item.text, { underline: true });
              doc.moveDown();
              break;
            case 'paragraph':
              doc.fontSize(12).text(item.text);
              doc.moveDown();
              break;
            case 'bullet-list':
              doc.fontSize(12).list(item.items);
              doc.moveDown();
              break;
            case 'code':
              doc.fontSize(10).fillColor('gray').text(item.code);
              doc.fillColor('black');
              doc.moveDown();
              break;
            case 'page-break':
              doc.addPage();
              break;
            default:
              break;
          }
        });
      }
    }

    // Function to extract chapters and subheadings
    function extractChaptersAndSubheadings(text) {
      const lines = text.split('\n');
      const items = [];
      lines.forEach(line => {
        if (line.startsWith('## ')) {
          // Chapter
          items.push({ type: 'chapter', text: line.substring(3).trim() });
        } else if (line.startsWith('### ')) {
          // Subheading
          items.push({ type: 'subheading', text: line.substring(4).trim() });
        }
      });
      return items;
    }

    // Function to populate the popup menu
    function populatePopupMenu() {
      const text = textEditor.value;
      const items = extractChaptersAndSubheadings(text);
      const popupMenu = document.getElementById('popup-menu');
      popupMenu.innerHTML = ''; // Clear existing content

      const ul = document.createElement('ul');
      items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = `${item.type === 'chapter' ? 'Chapter: ' : 'Subheading: '} ${item.text}`;
        ul.appendChild(li);
      });

      if (items.length === 0) {
        const li = document.createElement('li');
        li.textContent = 'No chapters or subheadings found.';
        ul.appendChild(li);
      }

      popupMenu.appendChild(ul);
    }

    // Event listener for the menu button
    const menuButton = document.getElementById('menu-button');
    menuButton.addEventListener('click', () => {
      const popupMenu = document.getElementById('popup-menu');
      if (popupMenu.style.display === 'block') {
        popupMenu.style.display = 'none';
      } else {
        populatePopupMenu();
        popupMenu.style.display = 'block';
      }
    });

    // Event listener for the assistant button
    const assistants = [
      { id: 'assistant_1', name: 'Assistant 1' },
      { id: 'assistant_2', name: 'Assistant 2' },
      { id: 'assistant_3', name: 'Assistant 3' },
      // ... add more assistants as needed
    ];

    let selectedAssistant = null;

    function populateAssistantMenu() {
      const assistantMenu = document.getElementById('assistant-menu');
      assistantMenu.innerHTML = ''; // Clear existing content

      const ul = document.createElement('ul');
      assistants.forEach(assistant => {
        const li = document.createElement('li');
        li.textContent = assistant.name;
        li.dataset.assistantId = assistant.id;
        // Highlight if selected
        if (selectedAssistant && selectedAssistant.id === assistant.id) {
          li.style.backgroundColor = '#e0e0e0';
        }
        li.addEventListener('click', () => {
          selectedAssistant = assistant;
          assistantMenu.style.display = 'none';
          // Optionally update the assistant button to show selection
          document.getElementById('assistant-button').style.backgroundColor = '#34A853'; // Google Green
        });
        ul.appendChild(li);
      });

      assistantMenu.appendChild(ul);
    }

    const assistantButton = document.getElementById('assistant-button');
    assistantButton.addEventListener('click', () => {
      const assistantMenu = document.getElementById('assistant-menu');
      if (assistantMenu.style.display === 'block') {
        assistantMenu.style.display = 'none';
      } else {
        populateAssistantMenu();
        assistantMenu.style.display = 'block';
      }
    });

    // Hide the popup menus when clicking outside
    document.addEventListener('click', function(event) {
      const isClickInsideMenu = menuButton.contains(event.target) ||
                                document.getElementById('popup-menu').contains(event.target) ||
                                assistantButton.contains(event.target) ||
                                document.getElementById('assistant-menu').contains(event.target);

      if (!isClickInsideMenu) {
        document.getElementById('popup-menu').style.display = 'none';
        document.getElementById('assistant-menu').style.display = 'none';
      }
    });

    // Event listener for the submit button
    const submitButton = document.getElementById('submit-button');
    submitButton.addEventListener('click', () => {
      const inputField = document.getElementById('floating-input-field');
      const prompt = inputField.value.trim();

      if (!selectedAssistant) {
        alert('Please select an assistant before submitting your prompt.');
        return;
      }

      if (prompt) {
        // Get the current JSON data
        const currentJson = plainTextToJson(textEditor.value);

        // Prepare the request payload
        const payload = {
          assistant_id: selectedAssistant.id,
          prompt: prompt,
          book_data: currentJson,
        };

        // Send the REST request
        fetch('http://my-wrapper.local:3434', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        })
          .then(response => response.json())
          .then(data => {
            // Handle the response from the wrapper
            // For example, update the editor with new content
            if (data && data.updated_book_data) {
              // Convert updated book data back to plain text
              const updatedText = jsonToPlainText(data.updated_book_data);
              textEditor.value = updatedText;
              // Trigger the input event to update the PDF
              textEditor.dispatchEvent(new Event('input'));
            }
          })
          .catch(error => {
            console.error('Error:', error);
            alert('An error occurred while communicating with the assistant.');
          });

        // Clear the input field
        inputField.value = '';
      }
    });

    // Prevent event propagation when clicking inside the floating input
    document.querySelector('.floating-input').addEventListener('click', function(event) {
      event.stopPropagation();
    });

    // Event listener for the text editor with debouncing
    let timeout = null;
    textEditor.addEventListener('input', () => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        const content = textEditor.value;
        generatePDF(content);
        // Update the popup menu if it's open
        const popupMenu = document.getElementById('popup-menu');
        if (popupMenu.style.display === 'block') {
          populatePopupMenu();
        }
      }, 500);
    });

    // Generate initial PDF
    if (typeof textEditor !== 'undefined') {
      generatePDF(textEditor.value);
    }
  </script>
</body>
</html>